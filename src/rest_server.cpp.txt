#include "rest_server.h"
#include <iostream>
#include <cstring>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

RestServer::RestServer(int port, int num_threads)
    : port_(port), num_threads_(num_threads), running_(false), server_socket_(-1) {
}

RestServer::~RestServer() {
    stop();
}

void RestServer::start() {
    if (running_.load()) {
        std::cerr << "Server already running" << std::endl;
        return;
    }

    // Create socket
    server_socket_ = socket(AF_INET, SOCK_STREAM, 0);
    if (server_socket_ < 0) {
        std::cerr << "Failed to create socket" << std::endl;
        return;
    }

    // Set socket options
    int opt = 1;
    if (setsockopt(server_socket_, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt)) < 0) {
        std::cerr << "Failed to set socket options" << std::endl;
        close(server_socket_);
        return;
    }

    // Bind socket
    struct sockaddr_in address;
    address.sin_family = AF_INET;
    address.sin_addr.s_addr = INADDR_ANY;
    address.sin_port = htons(port_);

    if (bind(server_socket_, (struct sockaddr*)&address, sizeof(address)) < 0) {
        std::cerr << "Failed to bind socket to port " << port_ << std::endl;
        close(server_socket_);
        return;
    }

    // Listen
    if (listen(server_socket_, 10) < 0) {
        std::cerr << "Failed to listen on socket" << std::endl;
        close(server_socket_);
        return;
    }

    running_.store(true);
    std::cout << "REST Server starting on port " << port_ << " with " << num_threads_ << " threads" << std::endl;

    // Start worker threads
    for (int i = 0; i < num_threads_; ++i) {
        threads_.emplace_back(&RestServer::worker_thread, this, i);
    }
}

void RestServer::stop() {
    if (!running_.load()) {
        return;
    }

    running_.store(false);

    // Close server socket to unblock accept()
    if (server_socket_ >= 0) {
        close(server_socket_);
        server_socket_ = -1;
    }

    // Join all threads
    for (auto& thread : threads_) {
        if (thread.joinable()) {
            thread.join();
        }
    }
    threads_.clear();

    std::cout << "REST Server stopped" << std::endl;
}

bool RestServer::is_running() const {
    return running_.load();
}

void RestServer::worker_thread(int thread_id) {
    std::cout << "Worker thread " << thread_id << " started" << std::endl;

    while (running_.load()) {
        struct sockaddr_in client_addr;
        socklen_t client_len = sizeof(client_addr);

        // Accept incoming connection
        int client_socket = accept(server_socket_, (struct sockaddr*)&client_addr, &client_len);

        if (client_socket < 0) {
            if (running_.load()) {
                std::cerr << "Thread " << thread_id << ": Failed to accept connection" << std::endl;
            }
            break;
        }

        // Handle the request
        handle_request(client_socket);

        // Close client socket
        close(client_socket);
    }

    std::cout << "Worker thread " << thread_id << " stopped" << std::endl;
}

void RestServer::handle_request(int client_socket) {
    char buffer[4096] = {0};

    // Read request
    ssize_t bytes_read = read(client_socket, buffer, sizeof(buffer) - 1);
    if (bytes_read < 0) {
        return;
    }

    // Parse request (simple parsing)
    std::string request(buffer);
    std::string method, path;

    size_t space_pos = request.find(' ');
    if (space_pos != std::string::npos) {
        method = request.substr(0, space_pos);
        size_t path_end = request.find(' ', space_pos + 1);
        if (path_end != std::string::npos) {
            path = request.substr(space_pos + 1, path_end - space_pos - 1);
        }
    }

    // Log request
    std::cout << "Request: " << method << " " << path << std::endl;

    // Generate response
    std::string response_body = "{\"status\":\"ok\",\"method\":\"" + method + "\",\"path\":\"" + path + "\"}";
    std::string response =
        "HTTP/1.1 200 OK\r\n"
        "Content-Type: application/json\r\n"
        "Content-Length: " + std::to_string(response_body.length()) + "\r\n"
        "Connection: close\r\n"
        "\r\n" +
        response_body;

    // Send response
    write(client_socket, response.c_str(), response.length());
}
